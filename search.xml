<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hexo 博客迁移</title>
      <link href="/2018/11/25/hexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
      <url>/2018/11/25/hexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-博客迁移管理"><a href="#Hexo-博客迁移管理" class="headerlink" title="Hexo 博客迁移管理"></a>Hexo 博客迁移管理</h2><p>在公司电脑上部署后，博客只能在公司编辑，总有一点不方便。查找了一些资料，如何把博客迁移到自己的笔记本中。主要有两种方法，一个是新建仓库来放环境文件，另一个是通过分支进行管理。本文采用的是通过分支进行管理。现在记录下该过程，方便以后有需要的时候即时查看。<strong>本文只记录迁移的过程</strong></p><a id="more"></a><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>github上已经搭建好相关仓库。</li></ol><h3 id="原电脑的操作步骤"><a href="#原电脑的操作步骤" class="headerlink" title="原电脑的操作步骤"></a>原电脑的操作步骤</h3><ol><li><p>新建分支dev，该分支用来存储静待文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b  dev</span><br></pre></td></tr></table></figure></li><li><p>将github 上的仓库下载到本地,删除这个文件夹所有的除了.git文件外的所有文件。</p></li><li>将工作区的变化提交（包括删除文件）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;message&quot;</span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure></li></ol><p>4.复制.git文件到项目的根目录下。删除clone下来的文件夹。</p><h3 id="新电脑上环境搭建"><a href="#新电脑上环境搭建" class="headerlink" title="新电脑上环境搭建"></a>新电脑上环境搭建</h3><ol><li>安装node.js和git</li><li><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>下载仓库到本地</p></li><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>进入到themes下，下载主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next</span><br></pre></td></tr></table></figure></li></ol><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>完成以上工作后，两台电脑就可以通过git命令同步。<br>目前流程可能有不完善的地方，以后碰到会对文章做出修改。</p><p><strong>参考</strong>：<a href="https://www.jianshu.com/p/fceaf373d797" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP/HTTPS 学习笔记（一）</title>
      <link href="/2018/11/22/HTTP-HTTPS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/11/22/HTTP-HTTPS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><a id="more"></a><h3 id="HTTP请求准备"><a href="#HTTP请求准备" class="headerlink" title="HTTP请求准备"></a>HTTP请求准备</h3><ul><li>浏览器将域名发送给DNS服务器，服务器将域名解析为IP地址。</li><li>建立TCP连接。<h3 id="HTTP构建"><a href="#HTTP构建" class="headerlink" title="HTTP构建"></a>HTTP构建</h3></li><li>浏览器发送HTTP请求。请求格式如下<br><img src="/2018/11/22/HTTP-HTTPS-学习笔记（一）/Http构建.jpg" alt=""><br>一共有三个部分，分别是<strong>请求行</strong>，<strong>首部字段</strong>，<strong>正文实体</strong>。<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4></li><li><strong>方法</strong>：POST,PUT,GET,DELETE….</li><li><strong>URL</strong>：</li><li><strong>版本</strong>：协议版本<h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4>首部是通过key value的方式存储重要的字段。以下举例说明</li><li>Accept-Charset：客户端可以接受的字符集，防止服务器传过来另外的字符集，导致乱码。</li><li>Content-Type：正文的格式。</li></ul><p>高并发场景下的系统，在真正的业务逻辑前需要接入层，拦截静态资源请求。如下<br><img src="/2018/11/22/HTTP-HTTPS-学习笔记（一）/缓存拦截.jpg" alt=""></p><ul><li>Cache-control : 控制缓存</li></ul><p>通过max-age指令判断客户端是接受缓存层的资源还是经请求转发给应用集群。详细关于HTTP的缓存控制可以看一下这篇博客。<a href="http://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">HTTP缓存控制</a></p><h3 id="HTTP请求发送"><a href="#HTTP请求发送" class="headerlink" title="HTTP请求发送"></a>HTTP请求发送</h3><p>HTTP协议是基于TCP协议的，使用的是面向连接的方式发送请求。其发送的和路由转发原理一样。</p><h3 id="HTTP返回的构建"><a href="#HTTP返回的构建" class="headerlink" title="HTTP返回的构建"></a>HTTP返回的构建</h3><p>和HTTP构建相似<br><img src="/2018/11/22/HTTP-HTTPS-学习笔记（一）/Http返回的构建.jpg" alt=""></p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>优化</p><ul><li>压缩HTTP头，在每次需要携带大量key value的两端建立一个索引表，相同的头只发送索引表中的索引。</li><li>可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。</li></ul><h3 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h3><p>HTTP协议是基于TCP协议的，在处理包时有严格的顺序。会导致当一个包没有接受到时，必须等待包传输完成才可以进行。</p><ul><li>自定义连接机制</li><li>自定义重传机制</li><li>无阻塞多路复用</li><li>自定义流量控制<br>关于QUIC的详细介绍请看这篇博客：<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">QUIC介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树基本总结</title>
      <link href="/2018/11/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>整理极客时间《数据结构和算法之美》内容，加深自己印象。后期通刷题对应相应的知识点部分。<br><a id="more"></a></p><h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>节点（父节点、子节点、兄弟节点、根节点、叶子节点）</li><li>树的定义（完全二叉树、满二叉树）</li><li>高度、深度、层数</li></ol><h3 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h3><h5 id="1-如何存储一棵二叉树"><a href="#1-如何存储一棵二叉树" class="headerlink" title="1.如何存储一棵二叉树"></a>1.如何存储一棵二叉树</h5><ol><li>基于指针或者引用二叉链式存储法</li><li>基于数组的顺序存储法</li></ol><p><strong>链式存储法</strong><br>每个节点有三个字段，一个用来存储数据，另外两个分别是指向左右子节点的指针</p><p><strong>顺序存储法</strong><br>如果节点X存储在数组中下标为i的位置，下标为2i的位置存储的就是左子节点。如果2i+1的位置就是右子节点。反过来i/2就是其根节点。</p><blockquote><p>完全二叉树要求最后一层的子节点全部靠左是因为这样用数组存储节省内存，不需要像链式存储使用额外的存储空间。</p></blockquote><h5 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2.二叉树的遍历"></a>2.二叉树的遍历</h5><ol><li>前序遍历</li><li>中序遍历</li><li>后续遍历</li><li>按层遍历（少见）</li></ol><h5 id="3-二叉查找树"><a href="#3-二叉查找树" class="headerlink" title="3.二叉查找树"></a>3.二叉查找树</h5><ol><li>二叉查找树的查找</li><li>二叉查找树的插入</li><li>二叉查找树的删除</li><li>二叉查找树查找最大节点和最小节点</li><li>二叉查找树查找前驱节点和后继节点</li></ol><blockquote><p>中序遍历的二叉树可以输出有序的数据序列，时间复杂度是O(n)</p></blockquote><h5 id="4-支持重度数据的二叉查找树"><a href="#4-支持重度数据的二叉查找树" class="headerlink" title="4.支持重度数据的二叉查找树"></a>4.支持重度数据的二叉查找树</h5><ol><li>每一个节点上不止同时存储一个数据。通过链表和动态扩容的数组等数据结构，把值相同的数据存储在同一个节点上。</li><li>在查找插入位置的过程中，如果碰到相同的数据，则交给二叉查找树的右节点当做一个新的数处理。查找的时候停止条件为遇到叶子节点。</li></ol><blockquote><p><strong>时间复杂度</strong>：O(log(n))</p></blockquote><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h5 id="如何求出一个二叉树的高度"><a href="#如何求出一个二叉树的高度" class="headerlink" title="如何求出一个二叉树的高度"></a>如何求出一个二叉树的高度</h5><ol><li>深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；</li><li>可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。</li></ol><h5 id="散列表的插入、删除、查找的时间复杂度O-1-。为什么要用二叉树？"><a href="#散列表的插入、删除、查找的时间复杂度O-1-。为什么要用二叉树？" class="headerlink" title="散列表的插入、删除、查找的时间复杂度O(1)。为什么要用二叉树？"></a>散列表的插入、删除、查找的时间复杂度O(1)。为什么要用二叉树？</h5><ol><li>散列表是无序的，而对于二叉查找树，只要中序遍历即可。</li><li>散列表扩容耗时多，当遇到散列冲突时，性能不稳定。虽然二叉查找树的性能不稳定，但是平衡二叉树性能稳定。</li><li>因哈希冲突的存在，常量的复杂度有可能比logn大。所以在实际应用中，速度并不一定会比平衡二叉树快。</li><li>散列表构造复杂：散列函数设计，冲突解决办法，扩容，缩容等。平衡二叉树只需要考虑平衡性这个问题，且该问题的解决方案成熟，固定。</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java时间戳</title>
      <link href="/2018/11/21/java%E6%97%B6%E9%97%B4%E6%88%B3/"/>
      <url>/2018/11/21/java%E6%97%B6%E9%97%B4%E6%88%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="java时间戳"><a href="#java时间戳" class="headerlink" title="java时间戳"></a>java时间戳</h3><a id="more"></a><hr><h4 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h4><p>一共三种方法</p><ul><li>System.currentTimeMillis();  </li><li>Calendar.getInstance().getTimeInMillis()；</li><li>new Date().getTime()；</li></ul><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><blockquote><p>SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);//设置日期格式<br>String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳</p></blockquote><p>仿照博客进行了时间测试。分别测试一次，时间差别不大。查看博客上的测试都是测试十万次。这样测得的数据才具有代表性。<br><a href="https://blog.csdn.net/qq_15037231/article/details/78224321" target="_blank" rel="noopener">参考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用工具集</title>
      <link href="/2018/11/17/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
      <url>/2018/11/17/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。</p><a id="more"></a><hr><h2 id="常用工具-1"><a href="#常用工具-1" class="headerlink" title="常用工具"></a>常用工具</h2><p>平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。</p><h3 id="terminus"><a href="#terminus" class="headerlink" title="terminus"></a>terminus</h3><ul><li>一款非常好用的远程连接工具。目前支持的windows、Android、ios、linux。<br><a href="https://www.termius.com/" target="_blank" rel="noopener">下载链接</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>测试工具Junit</title>
      <link href="/2018/11/04/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Junit/"/>
      <url>/2018/11/04/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Junit/</url>
      
        <content type="html"><![CDATA[<h1 id="Junit使用"><a href="#Junit使用" class="headerlink" title="Junit使用"></a>Junit使用</h1><a id="more"></a><hr><h2 id="Junit-简介"><a href="#Junit-简介" class="headerlink" title="Junit 简介"></a>Junit 简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>JUnit是用于编写和运行测试的开源框架。</li><li>提供了注释，以确定测试方法。</li><li>提供断言测试预期结果。</li><li>提供了测试运行的运行测试。</li><li>JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。</li><li>它是不那么复杂以及不需要花费太多的时间。</li><li>JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</li><li>JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。</li><li>Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</li></ul><h2 id="Junit-安装使用"><a href="#Junit-安装使用" class="headerlink" title="Junit 安装使用"></a>Junit 安装使用</h2><ol><li>笔者使用的是<strong>Intellij IDEA</strong>编辑器，该软件在安装时已经默认配置了Junit单元测试插件，读者可以尝试在<strong>“File-&gt;Settings-&gt;Plugins”</strong>下搜索JUnit，如果没有请自行安装。安装好应用后重启编辑器即可。</li><li>在工程目录下创建test目录用于存放测试类，在此目录上右击鼠标并将此目录标记为Test Resources Root。</li><li>选择需要测试的类文件，右键点击选择<strong>go to -&gt;test</strong>,然后点击create new test <img src="/2018/11/04/测试工具Junit/Junit_1.jpg" alt=""></li><li>选择必要的选项，然后选择需要测试的方法，添加完成后即可生成测试方法。<img src="/2018/11/04/测试工具Junit/Junit_2.png" alt=""></li><li>在测试方法中添加具体的实现内容后，即可执行相应的测试内容。<img src="/2018/11/04/测试工具Junit/Junit_3.png" alt=""></li></ol><h3 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h3><ol><li>@Test: 测试方法<br>　　　　a)(expected=XXException.class)如果程序的异常和XXException.class一样，则测试通过<br>　　　　b)(timeout=100)如果程序的执行能在100毫秒之内完成，则测试通过</li><li>@Ignore: 被忽略的测试方法：加上之后，暂时不运行此段代码</li><li>@Before: 每一个测试方法之前运行</li><li>@After: 每一个测试方法之后运行</li><li>@BeforeClass: 方法必须必须要是静态方法（static 声明），所有测试开始之前运行，注意区分before，是所有测试方法</li><li>@AfterClass: 方法必须要是静态方法（static 声明），所有测试结束之后运行，注意区分 @After</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
