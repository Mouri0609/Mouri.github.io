<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java设计模式学习笔记（模式比较）]]></title>
    <url>%2F2019%2F02%2F21%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[模板方法模式V策略模式模板方法模式 定义一个算法大纲，子类定义部分具体内容。 提高了代码的复用 策略模式 定义了一个算法家族，让这些算法可以互换。通过对象组合的方式，让客户可以选择这些算法实现。 更有弹性，客户可以在运行时通过选择不同的策略对象动态地改变算法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式学习笔记——策略模式]]></title>
    <url>%2F2019%2F02%2F21%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[问题在软件开发中，我们会碰到类似的情况，实现一个功能有多种途径，比如游乐园打折方案：老人，成人，儿童，亲子等不同打折模式。如果将这些打折方案的具体实现写进了同一个Ticket()类中，会出现以下三个问题： Ticket类的calculate()方法非常庞大，它包含各种打折算法的实现代码，在代码中出现了较长的if…else…语句，不利于测试和维护。 增加新的打折算法或者对原有打折算法进行修改时必须修改Ticket类的源代码，违反了“开闭原则”，系统的灵活性和可扩展性较差。 算法的复用性差，如果在另一个系统（如商场销售管理系统）中需要重用某些打折算法，只能通过对源代码进行复制粘贴来重用，无法单独重用其中的某个或某些算法（重用较为麻烦）。 策略模式 策略模式定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 代码demo在github上star了一个设计模式的教程，不仅会讲解，最后还会给出题目练习。题目如下： Sunny软件公司欲开发一款飞机模拟系统，该系统主要模拟不同种类飞机的飞行特征与起飞特征，需要模拟的飞机种类及其特征如表24-1所示：表24-1 飞机种类及特征一览表 飞机种类 起飞特征 飞行特征 直升机(Helicopter) 垂直起飞(VerticalTakeOff) 亚音速飞行(SubSonicFly) 客机(AirPlane) 长距离起飞(LongDistanceTakeOff) 亚音速飞行(SubSonicFly) 歼击机(Fighter) 长距离起飞(LongDistanceTakeOff) 超音速飞行(SuperSonicFly) 鹞式战斗机(Harrier) 垂直起飞(VerticalTakeOff) 超音速飞行(SuperSonicFly) 为将来能够模拟更多种类的飞机，试采用策略模式设计该飞机模拟系统。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class Plane &#123; //维持飞机行为抽象类的引用 FlySpeed flySpeed; StartBehavior startBehavior; public Plane()&#123; &#125; public void setFly(FlySpeed fly) &#123; this.flySpeed = fly; &#125; public void performFly() &#123; flySpeed.fly(); &#125; public void setStart(StartBehavior start) &#123; this.startBehavior = start; &#125; public void performStart() &#123; startBehavior.start(); &#125;&#125;public interface StartBehavior &#123; public void start();&#125;public interface FlySpeed &#123; public void fly();&#125;public class Helicopter extends Plane &#123; public Helicopter() &#123; flySpeed = new SubSonicFly(); startBehavior = new VerticalTakeOff(); &#125;&#125;public class Fighter extends Plane &#123; public Fighter() &#123; flySpeed = new SuperSonicFly(); startBehavior = new LongDistanceTakeOff(); &#125;&#125; 起飞特征实现1234567891011public class LongDistanceTakeOff implements StartBehavior &#123; public void start()&#123; System.out.println("LongDistanceTakeOff"); &#125;&#125;public class VerticalTakeOff implements StartBehavior &#123; public void start()&#123; System.out.println("VerticalTakeOff"); &#125;&#125; 飞行特征实现1234567891011public class SubSonicFly implements FlySpeed &#123; public void fly()&#123; System.out.println("SubSonicFly"); &#125;&#125;public class SuperSonicFly implements FlySpeed &#123; public void fly()&#123; System.out.println("SuperSonicFly"); &#125;&#125; 测试123456789101112131415public class test &#123; public static void main(String[] args) &#123; Plane helicopter = new Helicopter(); helicopter.performFly(); helicopter.performStart(); helicopter.setStart(new LongDistanceTakeOff()); //修改起飞行为 helicopter.performStart(); System.out.println("======================="); Plane fighter = new Fighter(); fighter.performFly(); fighter.performStart(); &#125;&#125; 输出结果123456SubSonicFlyVerticalTakeOffLongDistanceTakeOff=======================SuperSonicFlyLongDistanceTakeOff 可以看到能够动态的修改飞机的行为，如果需要扩展一种新的飞机，无需修改原来的代码。 优点 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。 策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况。 适用场景 一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据“里氏代换原则”和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象。 一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句。 不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式学习笔记——模板方法模式]]></title>
    <url>%2F2019%2F02%2F20%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法的结构下，重新定义算法中的某些步骤。 代码demo国外人部分人的生活习惯和国内大部分人不同，举例早上起床。电影中常看到国外人起床一般都是先洗澡，然后再洗漱吃早餐。程序代码如下： 模板抽象类 12345678910111213141516171819202122232425262728293031323334353637383940package designPattern.TemplateMethod;/** * Created by Mouri on 2019/2/20 16:59 */public abstract class WakeUpTemplate &#123; public final void wakeup() &#123; leaveBed(); if(IsTakeBath())&#123; takeBath(); &#125; brushTooth(); washFace(); eatBrakefast(); &#125; protected void leaveBed() &#123; System.out.println("leave the bed first!"); &#125; protected void takeBath()&#123; System.out.println("foreigner always take bathes first"); &#125;; protected boolean IsTakeBath()&#123; return false; &#125; protected void brushTooth()&#123; System.out.println("brush our tooth"); &#125;; protected void washFace() &#123; System.out.println("wash your face!"); &#125; protected abstract void eatBrakefast();&#125; 国内人起床的实现 1234567891011package designPattern.TemplateMethod;/** * Created by Mouri on 2019/2/20 17:20 */public class Chinese extends WakeUpTemplate &#123; @Override protected void eatBrakefast() &#123; System.out.println("Chinese likes soybean milk and congee"); &#125;&#125; 国外人的起床实现 12345678910111213141516package designPattern.TemplateMethod;/** * Created by Mouri on 2019/2/20 17:23 */public class American extends WakeUpTemplate &#123; @Override protected void eatBrakefast() &#123; System.out.println("American like milk and bread"); &#125; @Override protected boolean IsTakeBath()&#123; return true; &#125;&#125; 测试 1234567891011121314package designPattern.TemplateMethod;/** * Created by Mouri on 2019/2/20 17:25 */public class test &#123; public static void main(String[] args) &#123; WakeUpTemplate wakeUpByChinese = new Chinese(); WakeUpTemplate wakeUpByAmerican = new American(); wakeUpByChinese.wakeup(); System.out.println("==============================="); wakeUpByAmerican.wakeup(); &#125;&#125; 输出结果12345678910leave the bed first!brush our toothwash your face!Chinese likes soybean milk and congee===============================leave the bed first!foreigner always take bathes firstbrush our toothwash your face!American like milk and bread 通过子类的继承实现了不同的父类的步骤流程的细节，提高代码的复用。如果某步骤的执行需要判断条件，则可以在父类的模板方法中引入判断语句，如果子类需要实现该方法。则重写父类方法，将判断的值进行修改。 优点 子类在实现详细的处理流程时，不会打乱复杂的步骤的执行程序。 通过恰当的继承实现代码的复用。 可通过子类来覆盖父类的基本方法，更换和增加子类很方便，符合单一职责和开闭原则。 缺点 如果父类中的可变方法较多，则系统会变得庞大。此时可以结合桥接的模式进行设计（暂时没有学习） 适用场景 对一个算法或者流程中进行分析，将其中不变的部分设计成模板方法和父类具体方法，并将可变部分交给子类来实现。 子类的公共行为应被集中到公共父类避免代码重复。 需要通过子类来决定父类算法某个步骤的具体行为。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[srsLTE安装]]></title>
    <url>%2F2019%2F01%2F28%2FsrsLTE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[介绍srsLTE的安装配置，方便实验环境快速搭建。 更改apt源，安装必要工具 备份源文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 安装vimsudo apt install vim 编辑源文件sudo vim /etc/apt/sources.list 注释所有内容，并加入以下内容 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse 更新软件包及列表sudo apt updatesudo apt upgrade 安装gitsudo apt install git 安装requestssudo apt install python-pippip install requests UHD安装 下载驱动的源码并切换到稳定的版本 123git clone https://github.com/EttusResearch/uhdcd uhdgit checkout release_003_010_000_000 安装依赖sudo apt-get install libboost-all-dev libusb-1.0-0-dev python-cheetah doxygen python-docutils g++ cmake python-setuptools python-mako 编译 12345678cd uhd/host/ mkdir build cd build cmake ../ make -j2 make test sudo make install sudo ldconfig //更新动态链接库 srsLTE依赖库安装 依赖（Ubuntu 17.04及以上）sudo apt-get install cmake libfftw3-dev libmbedtls-dev libboost-program-options-dev libboost-thread-dev libconfig++-dev libsctp-devsrsGUI库安装 依赖sudo apt-get install libboost-system-dev libboost-test-dev libboost-thread-dev libqwt-dev libqt4-dev 下载及安装命令 12345678git clone https://github.com/suttonpd/srsgui.git cd srsGUI mkdir build cd build cmake ../ make sudo make install sudo ldconfig srsLTE编译运行 下载及编译git clone https://github.com/srsLTE/srsLTE cd srsLTE mkdir build cd build cmake ../ make -j2 make test sudo make install sudo ldconfig srsLTE模块运行在srsLTE文件夹下分别有srsepc,srsenb,srsue三个子文件夹。分别进入文件夹后备份配置文件并修改后缀名称并运行，以srsue为例。cd srsuecp ue.conf.example ue.confsudo srsue ue.conf 暂时没有硬件，配置文件修改部分以后添加。为了方便阅读源码，安装codeblockssudo pip install codeblocks]]></content>
      <categories>
        <category>SDR</category>
      </categories>
      <tags>
        <tag>srsLTE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium工具学习]]></title>
    <url>%2F2019%2F01%2F13%2Fselenium%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[如何了解selenium&emsp;&emsp;最近女朋友的导师实验室发现了一个叫做TimeTree的网站，让他的学生每天23:00（原来是24:00）登录网页预约实验仪器。我帮抢过几次，非常不方便，快到十一点的时候就要守在电脑旁边。就准备写个定时任务的脚本，帮我提交。&emsp;&emsp;刚开始想通过requests的方法将预约的时间和日期提交请求，但是发现在request header里面含有CSRF-token。了实验室同学，同学推荐使用selenium工具。 selenium简介&emsp;&emsp;Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。https://baike.baidu.com/item/selenium/18266 安装和配置 pip安装pip install selenium 下载驱动谷歌驱动链接 下载解压后，将chromedriver.exe,移动到Python的安装目录。然后再将Python的安装目录添加到系统环境变量的Path下面。 代码链接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899from selenium import webdriverfrom selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom datetime import datetime, timedeltafrom time import sleepimport timeimport requestsimport jsonEMAIL = &quot;abc@qq.com&quot;PASSWORD = &quot;123&quot;#时间将24小时制乘以2对应。#例如#12:00——24；13:30——27startTime = 25endTime = 35#日期#Day是抢的日期在本月日历（5*7或者4*7的矩阵）排第几，例如在2019年一月的日历中含有12.31一天，则1.1号就记作2。Day = 17EventTitle = &quot;CQQ&quot;SECONDS_PER_DAY = 24 * 60 * 60def doLogin(): browser = webdriver.Chrome() browser.get(&apos;https://timetreeapp.com/signin&apos;) #登录 browser.find_element_by_xpath(&quot;//input[@placeholder=&apos;邮箱地址&apos;]&quot;).send_keys(EMAIL) browser.find_element_by_xpath(&quot;//input[@placeholder=&apos;8~32 个字符的密码&apos;]&quot;).send_keys(PASSWORD) browser.find_element_by_xpath(&quot;//input[@value=&apos;登陆&apos;]&quot;).click() #选择日期 element = WebDriverWait(browser,30).until(EC.presence_of_element_located( (By.XPATH,&apos;//*[@id=&quot;root&quot;]/div/div/div[1]/div[2]/div/div/div/div[1]/div[3]/div/div[1]/div[2]/div[3]/div[2]/div[3]&apos;))) # day = browser.find_element_by_xpath(&apos;//*[@id=&quot;root&quot;]/div/div/div[1]/div[2]/div/div/div/div[1]/div[3]/div/div[1]/div[2]/div[3]/div[2]/div[3]&apos;) day = browser.find_elements_by_class_name(&apos;dayCell&apos;)[Day-1] # 双击不知道为啥不行 # ActionChains(browser).double_click(day).perform() day.click() day.click() browser.find_element_by_css_selector(&quot;.more.clickable&quot;).click() #取消全天 wholeDay = browser.find_elements_by_class_name(&quot;inner&quot;)[0] wholeDay.click() #EventTitle eventTitle = browser.find_element_by_xpath(&apos;//*[@id=&quot;root&quot;]/div/div/div[1]/div[2]/div/div/div/div[1]/div[3]/div/div[2]/div[2]/span/div/div/div/div[3]/textarea&apos;) eventTitle.send_keys(EventTitle) #开始时间 browser.find_elements_by_class_name(&quot;bottomButton&quot;)[0].click() # browser.find_element_by_xpath(&apos;//*[@id=&quot;root&quot;]/div/div/div[1]/div[2]/div/div/div/div[1]/div[3]/div/div[2]/div[2]/span/div/div/div/div[4]/div[1]/span/div/div/div[2]/a[33]&apos;).click() browser.find_elements_by_css_selector(&quot;.clickable.row&quot;)[startTime].click() time.sleep(0.5) #结束时间 browser.find_elements_by_class_name(&quot;bottomButton&quot;)[1].click() # browser.find_element_by_xpath(&apos;//*[@id=&quot;root&quot;]/div/div/div[1]/div[2]/div/div/div/div[1]/div[3]/div/div[2]/div[2]/span/div/div/div/div[4]/div[2]/span/div/div/div[2]/a[41]&apos;).click() browser.find_elements_by_css_selector(&quot;.clickable.row&quot;)[endTime].click() curTime = datetime.now() print(&quot;当前时间:%s&quot; % curTime) desTime = curTime.replace(hour=23, minute=0, second=0, microsecond=0) print(&quot;抢AkTa时间:%s&quot; % desTime) leftTime = desTime - curTime sleepSecondSave = leftTime.total_seconds() time.sleep(sleepSecondSave) finnalSave = browser.find_elements_by_class_name(&quot;withChildren&quot;)[2] finnalSave.click() time.sleep(60) browser.close() print (&quot;今天已经抢了&quot;)def doFirst(): curTime = datetime.now() print(&quot;当前时间:%s&quot; % curTime) loginTime = curTime.replace(hour=22, minute=58, second=0, microsecond=0) print(&quot;登录时间:%s&quot; % loginTime) delta = loginTime - curTime print(delta) sleepSecondLogin = delta.total_seconds() time.sleep(sleepSecondLogin) doLogin()if __name__ == &quot;__main__&quot;: doFirst() 参考链接1.chromedriver与chrome版本映射表2.selenium-python中文文档]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ms12-020渗透攻击实战]]></title>
    <url>%2F2018%2F12%2F26%2Fms12-020%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[实验环境 攻击机 操作系统：kali IP地址：172.0.0.10 靶机 操作系统：win7 IP地址：172.0.0.12 端口开放：3389 准备工作 确保两台主机在局域网内相互ping通 靶机检查自己开放端口，确保3389端口开放。 操作步骤准备工作一、 两台主机在局域网内网络互通 登录攻击机账号：debian密码：kalidebian 右键选择-&gt;Open Terminal Here打开命令行终端 输入ip address确认自己的IP地址可以看到本机的IP地址为172.0.0.10 使用nmap命令扫描局域网内其他主机nmap -sP 172.0.0.0-255其中172.0.0.2是dhcp服务，可以看到。除了这两个IP。还扫描到一个IP地址为172.0.0.12的主机，这就是靶机的IP地址。 如果没有发现其他主机，请确认靶机防火墙已经关闭。二、靶机端口3389端口开放 点击搜索符号，输入Zenmap并打开。 在target输入靶机的IP地址信息并点击scan。 可以看到靶机的开放端口信息，其中包含3389端口。如果3389端口没有开放，则需要登录靶机并开启3389端口。 ms12-020漏洞攻击 登录攻击机，打开命令行终端 输入命令msfconsole进入MSF终端 在MSF终端对目标漏洞进行查找相对应的漏洞利用模块search ms12-020use auxiliary/dos/windows/rdp/ms12_020_maxchannelids 配置目标主机和本机地址set RHOST 172.0.0.12set LHOST 172.0.0.10 对目标漏洞执行攻击，输入命令exploit 迅速切换到靶机界面，可以看到靶机界面显示蓝屏，然后自动重启。]]></content>
      <categories>
        <category>kali</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 常用命令操作]]></title>
    <url>%2F2018%2F12%2F10%2Fgit-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[公司项目开发中经常使用git进行代码管理，记录常用问题以及遇到问题的解决方法。目前写下只是一部分印象较深的，以后会根据项目中遇到的问题进行解决并更新记录。 基本操作 平时代码上传拉取远程仓库并上传到远程仓库。 1234git add .git commit -am &quot;message&quot;git pullgit push origin branchName 检查分支状态 1git status 分支切换 1git checkout branchName 撤销commit 12git loggit reset --hard ^HEAD 返回到相应的提交位置 1git reset --hard commit_id 一般操作 在新的环境下新建本地仓库并拉取远程。进入项目复制该项目的SSH路径,使用git bash或者cmd进入到改项目路径。123git clone git@...git add .git commit -am &quot;first commit&quot;]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[kali 渗透攻击Samba服务]]></title>
    <url>%2F2018%2F11%2F27%2Fkali-%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BBSamba%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[公司网站开发需要测试一下教学网站中的实验部分（一人两台实验机器，其中一台为kali，另一台为metasploitable）,看一下是否能正常使用。对kali工具不熟悉，找了几篇博客，并将主要流程记录下来。 使用postman发送请求，将两台虚拟机镜像的ID封装成json对象。后端接收到数据后，生成对应的虚拟机，打开openstack的dashboard可以看到生成两个虚拟机，信息如下(主要看主机名和IP)：后台返回kali的url。将url复制到浏览器中后开始操作。 准备工作nmap是一款专用的端口扫描工具，主要使用该工具发现局域网中的主机，和主机开放的端口。 主机扫描1nmap -sP 172.0.0.0-100 该命令是扫描发现局域网下IP为172.0.0.0-172.0.0.100下可以ping通的IP,结果如下。由图片可知，已经发现了IP为172.0.0.13的虚拟机。 端口扫描1nmap -sV 172.0.0.13 -A 该命令是发现主机开发的端口，通过扫描可以发现该主机开放了一些存在高危漏洞的端口。上图所示是该主机开放的所有端口，其中知道比较多的139、445等高危端口是开放的。 渗透攻击Samba服务Samba服务对应的端口有139和445等，只要开启这些端口后，主机就有可能存在Samba远程溢出漏洞。以下是攻击步骤： 启动MSF终端 1msfconsole 使用smb_version模块 1use exploit/multi/samba/usermap_script 设置RHOST选项 1set RHOST 172.0.0.13 启动渗透攻击 1exploit 等待完成，如果成功。使用Linux命令查询主机相关信息。例如查询系统当前用户和ip地址 12whoamiip address 这只是其中的一种漏洞，因为metasploitable是一个人工靶机，所以教程较多，攻击流畅。下面这篇博客里面还包含了其他的一些漏洞和攻击方法，可以参考。参考链接：Kali-Linux渗透攻击应用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客迁移]]></title>
    <url>%2F2018%2F11%2F25%2Fhexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Hexo 博客迁移管理在公司电脑上部署后，博客只能在公司编辑，总有一点不方便。查找了一些资料，如何把博客迁移到自己的笔记本中。主要有两种方法，一个是新建仓库来放环境文件，另一个是通过分支进行管理。本文采用的是通过分支进行管理。现在记录下该过程，方便以后有需要的时候即时查看。本文只记录迁移的过程 准备工作 github上已经搭建好相关仓库。 原电脑的操作步骤 新建分支dev，该分支用来存储静待文件。 1git checkout -b dev 将github 上的仓库下载到本地,删除这个文件夹所有的除了.git文件外的所有文件。 将工作区的变化提交（包括删除文件）。123git add -Agit commit -m &quot;message&quot;git push origin dev 4.复制.git文件到项目的根目录下。删除clone下来的文件夹。 新电脑上环境搭建 安装node.js和git 安装hexo 1npm install -g hexo-cli 下载仓库到本地 安装依赖 1npm install 进入到themes下，下载主题 1git clone https://github.com/iissnan/hexo-theme-next 同步完成以上工作后，两台电脑就可以通过git命令同步。目前流程可能有不完善的地方，以后碰到会对文章做出修改。 参考：参考链接]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS 学习笔记（一）]]></title>
    <url>%2F2018%2F11%2F22%2FHTTP-HTTPS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTTP协议 HTTP请求准备 浏览器将域名发送给DNS服务器，服务器将域名解析为IP地址。 建立TCP连接。HTTP构建 浏览器发送HTTP请求。请求格式如下一共有三个部分，分别是请求行，首部字段，正文实体。请求行 方法：POST,PUT,GET,DELETE…. URL： 版本：协议版本首部首部是通过key value的方式存储重要的字段。以下举例说明 Accept-Charset：客户端可以接受的字符集，防止服务器传过来另外的字符集，导致乱码。 Content-Type：正文的格式。 高并发场景下的系统，在真正的业务逻辑前需要接入层，拦截静态资源请求。如下 Cache-control : 控制缓存 通过max-age指令判断客户端是接受缓存层的资源还是经请求转发给应用集群。详细关于HTTP的缓存控制可以看一下这篇博客。HTTP缓存控制 HTTP请求发送HTTP协议是基于TCP协议的，使用的是面向连接的方式发送请求。其发送的和路由转发原理一样。 HTTP返回的构建和HTTP构建相似 HTTP2.0优化 压缩HTTP头，在每次需要携带大量key value的两端建立一个索引表，相同的头只发送索引表中的索引。 可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。 QUIC协议HTTP协议是基于TCP协议的，在处理包时有严格的顺序。会导致当一个包没有接受到时，必须等待包传输完成才可以进行。 自定义连接机制 自定义重传机制 无阻塞多路复用 自定义流量控制关于QUIC的详细介绍请看这篇博客：QUIC介绍]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树基本总结]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整理极客时间《数据结构和算法之美》内容，加深自己印象。后期通刷题对应相应的知识点部分。 二叉树基础基本概念 节点（父节点、子节点、兄弟节点、根节点、叶子节点） 树的定义（完全二叉树、满二叉树） 高度、深度、层数 常见知识点1.如何存储一棵二叉树 基于指针或者引用二叉链式存储法 基于数组的顺序存储法 链式存储法每个节点有三个字段，一个用来存储数据，另外两个分别是指向左右子节点的指针 顺序存储法如果节点X存储在数组中下标为i的位置，下标为2i的位置存储的就是左子节点。如果2i+1的位置就是右子节点。反过来i/2就是其根节点。 完全二叉树要求最后一层的子节点全部靠左是因为这样用数组存储节省内存，不需要像链式存储使用额外的存储空间。 2.二叉树的遍历 前序遍历 中序遍历 后续遍历 按层遍历（少见） 3.二叉查找树 二叉查找树的查找 二叉查找树的插入 二叉查找树的删除 二叉查找树查找最大节点和最小节点 二叉查找树查找前驱节点和后继节点 中序遍历的二叉树可以输出有序的数据序列，时间复杂度是O(n) 4.支持重度数据的二叉查找树 每一个节点上不止同时存储一个数据。通过链表和动态扩容的数组等数据结构，把值相同的数据存储在同一个节点上。 在查找插入位置的过程中，如果碰到相同的数据，则交给二叉查找树的右节点当做一个新的数处理。查找的时候停止条件为遇到叶子节点。 时间复杂度：O(log(n)) 常见问题如何求出一个二叉树的高度 深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1； 可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。 散列表的插入、删除、查找的时间复杂度O(1)。为什么要用二叉树？ 散列表是无序的，而对于二叉查找树，只要中序遍历即可。 散列表扩容耗时多，当遇到散列冲突时，性能不稳定。虽然二叉查找树的性能不稳定，但是平衡二叉树性能稳定。 因哈希冲突的存在，常量的复杂度有可能比logn大。所以在实际应用中，速度并不一定会比平衡二叉树快。 散列表构造复杂：散列函数设计，冲突解决办法，扩容，缩容等。平衡二叉树只需要考虑平衡性这个问题，且该问题的解决方案成熟，固定。 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java时间戳]]></title>
    <url>%2F2018%2F11%2F21%2Fjava%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[java时间戳 获取当前时间戳一共三种方法 System.currentTimeMillis(); Calendar.getInstance().getTimeInMillis()； new Date().getTime()； 获取当前时间 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);//设置日期格式String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 仿照博客进行了时间测试。分别测试一次，时间差别不大。查看博客上的测试都是测试十万次。这样测得的数据才具有代表性。参考博客]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具集]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%2F</url>
    <content type="text"><![CDATA[常用工具平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。 常用工具平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。 terminus 一款非常好用的远程连接工具。目前支持的windows、Android、ios、linux。下载链接 postman 后端开发中，测试接口返回信息的工具。下载链接]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试工具Junit]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Junit%2F</url>
    <content type="text"><![CDATA[Junit使用 Junit 简介简介 JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。 优点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。 它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 Junit 安装使用 笔者使用的是Intellij IDEA编辑器，该软件在安装时已经默认配置了Junit单元测试插件，读者可以尝试在“File-&gt;Settings-&gt;Plugins”下搜索JUnit，如果没有请自行安装。安装好应用后重启编辑器即可。 在工程目录下创建test目录用于存放测试类，在此目录上右击鼠标并将此目录标记为Test Resources Root。 选择需要测试的类文件，右键点击选择go to -&gt;test,然后点击create new test 选择必要的选项，然后选择需要测试的方法，添加完成后即可生成测试方法。 在测试方法中添加具体的实现内容后，即可执行相应的测试内容。 常用的注解 @Test: 测试方法 a)(expected=XXException.class)如果程序的异常和XXException.class一样，则测试通过 b)(timeout=100)如果程序的执行能在100毫秒之内完成，则测试通过 @Ignore: 被忽略的测试方法：加上之后，暂时不运行此段代码 @Before: 每一个测试方法之前运行 @After: 每一个测试方法之后运行 @BeforeClass: 方法必须必须要是静态方法（static 声明），所有测试开始之前运行，注意区分before，是所有测试方法 @AfterClass: 方法必须要是静态方法（static 声明），所有测试结束之后运行，注意区分 @After]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
