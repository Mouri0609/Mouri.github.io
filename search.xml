<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kali 渗透攻击Samba服务]]></title>
    <url>%2F2018%2F11%2F27%2Fkali-%E6%B8%97%E9%80%8F%E6%94%BB%E5%87%BBSamba%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[公司网站开发需要测试一下教学网站中的实验部分（一人两台实验机器，其中一台为kali，另一台为metasploitable）,看一下是否能正常使用。对kali工具不熟悉，找了几篇博客，并将主要流程记录下来。 使用postman发送请求，将两台虚拟机镜像的ID封装成json对象。后端接收到数据后，生成对应的虚拟机，打开openstack的dashboard可以看到生成两个虚拟机，信息如下(主要看主机名和IP)：后台返回kali的url。将url复制到浏览器中后开始操作。 准备工作nmap是一款专用的端口扫描工具，主要使用该工具发现局域网中的主机，和主机开放的端口。 主机扫描1nmap -sP 172.0.0.0-100 该命令是扫描发现局域网下IP为172.0.0.0-172.0.0.100下可以ping通的IP,结果如下。由图片可知，已经发现了IP为172.0.0.13的虚拟机。 端口扫描1nmap -sV 172.0.0.13 -A 该命令是发现主机开发的端口，通过扫描可以发现该主机开放了一些存在高危漏洞的端口。上图所示是该主机开放的所有端口，其中知道比较多的139、445等高危端口是开放的。 渗透攻击Samba服务Samba服务对应的端口有139和445等，只要开启这些端口后，主机就有可能存在Samba远程溢出漏洞。以下是攻击步骤： 启动MSF终端 1msfconsole 使用smb_version模块 1use exploit/multi/samba/usermap_script 设置RHOST选项 1set RHOST 172.0.0.13 启动渗透攻击 1exploit 等待完成，如果成功。使用Linux命令查询主机相关信息。例如查询系统当前用户和ip地址 12whoamiip address 这只是其中的一种漏洞，因为metasploitable是一个人工靶机，所以教程较多，攻击流畅。下面这篇博客里面还包含了其他的一些漏洞和攻击方法，可以参考。参考链接：Kali-Li nux渗透攻击应用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客迁移]]></title>
    <url>%2F2018%2F11%2F25%2Fhexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Hexo 博客迁移管理在公司电脑上部署后，博客只能在公司编辑，总有一点不方便。查找了一些资料，如何把博客迁移到自己的笔记本中。主要有两种方法，一个是新建仓库来放环境文件，另一个是通过分支进行管理。本文采用的是通过分支进行管理。现在记录下该过程，方便以后有需要的时候即时查看。本文只记录迁移的过程 准备工作 github上已经搭建好相关仓库。 原电脑的操作步骤 新建分支dev，该分支用来存储静待文件。 1git checkout -b dev 将github 上的仓库下载到本地,删除这个文件夹所有的除了.git文件外的所有文件。 将工作区的变化提交（包括删除文件）。123git add -Agit commit -m &quot;message&quot;git push origin dev 4.复制.git文件到项目的根目录下。删除clone下来的文件夹。 新电脑上环境搭建 安装node.js和git 安装hexo 1npm install -g hexo-cli 下载仓库到本地 安装依赖 1npm install 进入到themes下，下载主题 1git clone https://github.com/iissnan/hexo-theme-next 同步完成以上工作后，两台电脑就可以通过git命令同步。目前流程可能有不完善的地方，以后碰到会对文章做出修改。 参考：参考链接]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS 学习笔记（一）]]></title>
    <url>%2F2018%2F11%2F22%2FHTTP-HTTPS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTTP协议 HTTP请求准备 浏览器将域名发送给DNS服务器，服务器将域名解析为IP地址。 建立TCP连接。HTTP构建 浏览器发送HTTP请求。请求格式如下一共有三个部分，分别是请求行，首部字段，正文实体。请求行 方法：POST,PUT,GET,DELETE…. URL： 版本：协议版本首部首部是通过key value的方式存储重要的字段。以下举例说明 Accept-Charset：客户端可以接受的字符集，防止服务器传过来另外的字符集，导致乱码。 Content-Type：正文的格式。 高并发场景下的系统，在真正的业务逻辑前需要接入层，拦截静态资源请求。如下 Cache-control : 控制缓存 通过max-age指令判断客户端是接受缓存层的资源还是经请求转发给应用集群。详细关于HTTP的缓存控制可以看一下这篇博客。HTTP缓存控制 HTTP请求发送HTTP协议是基于TCP协议的，使用的是面向连接的方式发送请求。其发送的和路由转发原理一样。 HTTP返回的构建和HTTP构建相似 HTTP2.0优化 压缩HTTP头，在每次需要携带大量key value的两端建立一个索引表，相同的头只发送索引表中的索引。 可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。 QUIC协议HTTP协议是基于TCP协议的，在处理包时有严格的顺序。会导致当一个包没有接受到时，必须等待包传输完成才可以进行。 自定义连接机制 自定义重传机制 无阻塞多路复用 自定义流量控制关于QUIC的详细介绍请看这篇博客：QUIC介绍]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树基本总结]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整理极客时间《数据结构和算法之美》内容，加深自己印象。后期通刷题对应相应的知识点部分。 二叉树基础基本概念 节点（父节点、子节点、兄弟节点、根节点、叶子节点） 树的定义（完全二叉树、满二叉树） 高度、深度、层数 常见知识点1.如何存储一棵二叉树 基于指针或者引用二叉链式存储法 基于数组的顺序存储法 链式存储法每个节点有三个字段，一个用来存储数据，另外两个分别是指向左右子节点的指针 顺序存储法如果节点X存储在数组中下标为i的位置，下标为2i的位置存储的就是左子节点。如果2i+1的位置就是右子节点。反过来i/2就是其根节点。 完全二叉树要求最后一层的子节点全部靠左是因为这样用数组存储节省内存，不需要像链式存储使用额外的存储空间。 2.二叉树的遍历 前序遍历 中序遍历 后续遍历 按层遍历（少见） 3.二叉查找树 二叉查找树的查找 二叉查找树的插入 二叉查找树的删除 二叉查找树查找最大节点和最小节点 二叉查找树查找前驱节点和后继节点 中序遍历的二叉树可以输出有序的数据序列，时间复杂度是O(n) 4.支持重度数据的二叉查找树 每一个节点上不止同时存储一个数据。通过链表和动态扩容的数组等数据结构，把值相同的数据存储在同一个节点上。 在查找插入位置的过程中，如果碰到相同的数据，则交给二叉查找树的右节点当做一个新的数处理。查找的时候停止条件为遇到叶子节点。 时间复杂度：O(log(n)) 常见问题如何求出一个二叉树的高度 深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1； 可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。 散列表的插入、删除、查找的时间复杂度O(1)。为什么要用二叉树？ 散列表是无序的，而对于二叉查找树，只要中序遍历即可。 散列表扩容耗时多，当遇到散列冲突时，性能不稳定。虽然二叉查找树的性能不稳定，但是平衡二叉树性能稳定。 因哈希冲突的存在，常量的复杂度有可能比logn大。所以在实际应用中，速度并不一定会比平衡二叉树快。 散列表构造复杂：散列函数设计，冲突解决办法，扩容，缩容等。平衡二叉树只需要考虑平衡性这个问题，且该问题的解决方案成熟，固定。 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java时间戳]]></title>
    <url>%2F2018%2F11%2F21%2Fjava%E6%97%B6%E9%97%B4%E6%88%B3%2F</url>
    <content type="text"><![CDATA[java时间戳 获取当前时间戳一共三种方法 System.currentTimeMillis(); Calendar.getInstance().getTimeInMillis()； new Date().getTime()； 获取当前时间 SimpleDateFormat df = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);//设置日期格式String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 仿照博客进行了时间测试。分别测试一次，时间差别不大。查看博客上的测试都是测试十万次。这样测得的数据才具有代表性。参考博客]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用工具集]]></title>
    <url>%2F2018%2F11%2F17%2F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E9%9B%86%2F</url>
    <content type="text"><![CDATA[常用工具平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。 常用工具平时在学习中经常用到的方便快捷的小工具，总结一下并附上简单说明和下载链接。 terminus 一款非常好用的远程连接工具。目前支持的windows、Android、ios、linux。下载链接]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试工具Junit]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7Junit%2F</url>
    <content type="text"><![CDATA[Junit使用 Junit 简介简介 JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。 优点 JUnit是用于编写和运行测试的开源框架。 提供了注释，以确定测试方法。 提供断言测试预期结果。 提供了测试运行的运行测试。 JUnit测试让您可以更快地编写代码，提高质量 JUnit是优雅简洁。 它是不那么复杂以及不需要花费太多的时间。 JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。 JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。 Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。 Junit 安装使用 笔者使用的是Intellij IDEA编辑器，该软件在安装时已经默认配置了Junit单元测试插件，读者可以尝试在“File-&gt;Settings-&gt;Plugins”下搜索JUnit，如果没有请自行安装。安装好应用后重启编辑器即可。 在工程目录下创建test目录用于存放测试类，在此目录上右击鼠标并将此目录标记为Test Resources Root。 选择需要测试的类文件，右键点击选择go to -&gt;test,然后点击create new test 选择必要的选项，然后选择需要测试的方法，添加完成后即可生成测试方法。 在测试方法中添加具体的实现内容后，即可执行相应的测试内容。 常用的注解 @Test: 测试方法 a)(expected=XXException.class)如果程序的异常和XXException.class一样，则测试通过 b)(timeout=100)如果程序的执行能在100毫秒之内完成，则测试通过 @Ignore: 被忽略的测试方法：加上之后，暂时不运行此段代码 @Before: 每一个测试方法之前运行 @After: 每一个测试方法之后运行 @BeforeClass: 方法必须必须要是静态方法（static 声明），所有测试开始之前运行，注意区分before，是所有测试方法 @AfterClass: 方法必须要是静态方法（static 声明），所有测试结束之后运行，注意区分 @After]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
